# 4. 시간복잡도
## 4.1 도입
### 4.1.1 반복문이 지배한다
알고리즘의 수행시간을 지배하는것은 바로 반복문임.
입력에 관계없이 같은 수행시간을 가질수도 있지만 대개는 입력의 크기에 따라 수행횟수가 정해지는 반복문이 존재함.
이때 반복문의 수행횟수는 입력 크기에 대한 함수로 표현됨

~~~cpp

int N;
cin >> N;
for(int i =0;i<N;i++){
  for(int k =0;k<N;k++){
    cout << i << " " << k << "\n";
  }
}

~~~

다음과 같은 코드는 i 와 k 를 각각 N^2 번 출력하게 되므로 시간복잡도가 N^2라고 할 수 있음.

## 4.2 선형 시간 알고리즘
선형시간 알고리즘은 다음 과 같은 최대값 찾기 에서 찾을 수 있음

~~~cpp

arr[10] = {1,5,2,6,4,3,7,9,5,2};
int max = arr[0];
for(int i = 1;i<10;i++){
  if(max < arr[i]){
    max = arr[i];
  }
}
~~~

배열의 크기 인 N만큼 반복문의 수행횟수가 결정 되기 때문에 수행시간에 정비례 하게 되고
이것을 선형씨간 알고리즘이라고 일컫음. 일반적으로 모든 데이터를 생각 할 경우 선형시간 알고리즘이 가장 빠른 알고리즘이라 할 수 있음.

## 4.3 선형 이하 시간 알고리즘
### 4.3.1 이분탐색
{1,2,4,6,7,8,12,15,26,38}
다음 과 같은 정렬된 배열에서 15이라는 숫자를 찾기 위해서 몇번의 연산을 해야 할까.
가장 먼저 생각 할 수 있는 방법은 선형 시간 알고리즘으로 생각하는것이다.
모든 배열에 15와의 비교를 통해 해당 배열에서 15를 찾아낼 수 있는 것이다.
하지만 정렬된 배열에서는 절반을 나눠서 가운데 있는 배열과의 비교를 통해 수행횟수를 줄일 수 있다.
처음 배열에서 중앙은 8이고 이 숫자는 15보다 작은 숫자이므로 15라는 숫자가 존재한다면 중앙 이후의 인덱스에서 발견 될 것이다.
그러므로 이제 탐색해야하는 배열의 숫자는 반으로 줄게 될것이고 이것을 반복함으로써 수행 횟수를log(N) 으로 줄일 수 있다.
### 4.3.2 선형시간이 아닌 이유
설명대로라면 정렬된 배열이 필요 할 것이고 이거을 입력받는데 걸리는 시간복잡도는 O(N) 일 것이다. 그렇다면 입력을 받음과 동시에 15인지 아닌지를 판단 할 수 있을 것이다. 하지만 정렬된 배열에서 15라는 숫자를 제외한 다른 숫자, 예를들어 26을 반복적으로 찾고자 할때는 다시 O(N)의 시간복잡도를 가질것이므로 선형 시간 이하의 알고리즘인 이분탐색을 사용하는것이 효과적이다.

## 4.4 지수 시간 알고리즘
### 4.4.1 다항 시간 알고리즘
N^2 , N^3 ... N^ 100 등으로 표현되는 시간복잡도의 알고리즘을 다항시간 알고리즘이라 함.
하지만 N^100 인 경우 알고리즘이 엄청나게 느린데도 불구하고 굳이 다항시간 알고리즘이라 분류하는 이유는 그것보다 훨씬 느린 알고리즘이 존재하기 떄문임.

### 4.4.2 알러지가 심한 친구들
문제.
집들이에 N 명의 친구를 초대하려고 한다. 하지만 친구들은 각각 알러지 때문에 못먹는 음식이 있기 때문에 아무 음식이나 해서는 안된다.
할줄아는 M가지 음식 중 최소 몇가지 음식을 해야 모두가 먹을 수 있을까

다음과 같은 문제에서 모든 답 후보를 평가 하기 위해서는 M 가지 음식에 대해 그 음식을 만드는 경우와 만들지 않는 경우에 대해서 평가 하게 된다.
그렇다면 시간복잡도는 O(2^N) 이 될 것이고 N 이 증가하게 될수록 검사해야하는 경우의 수는 기하급수적으로 늘어날 것이다.

## 4.5 시간 복잡도
### 4.5.1 입력 종류에 따른 시간 복잡도
~~~cpp
int search = 5;
arr[6] = {1,2,3,4,5,6}
for(int i = 0; i < 6;i++){
  if(arr[i]){
    return i;
  }
}
~~~
위 코드는 해당 원소를 선형적으로 찾는 탐색 알고리즘이다.
똑같은 알고리즘이지만 어떠한 배열을 탐색하냐에 따라 시간복잡도는 변하게 된다.
만약 찾고자 하는 원소가 가장 앞에 있는 배열일 경우 시간복잡도는 O(1) 이 될것이다. 이것을 최선의 수행시간이라고 한다.
하지만 찾고자 하는 원소가 가장 마지막 배열에 있을 경우 시간복잡도는 O(N) 이 될것이다. 이것을 최악의 수행시간이라고 한다.
그리고 이 알고리즘은 평균적으로 N/2 회 시행되고 이것을 평균적인 수행시간이라 한다.
이 세개의 기준중 사람들이 대개 사용하는것은 최악의 수행시간 또는 수행 시간의 기대치이다.

### 4.5.2 점근적 시간 표기
우리가 사용하고자 하는 알고리즘의 시간복잡도가 3N^2 + 10N + 20이라고 합시다. 
시간복잡도 표기는 여기서 가장 빨리 증가하는 항에서 상수를 떼어낸 N^2 만을 표기하고 O(N^2)라고 표기합니다.

~~~cpp
int N;
cin >> N;
for(int i=0;i<N;i++){
  for(int k=0;k<N;k++){
    cout << i << " " << k << "\n";
  }
}
~~~
위와같은 코드는 N에 따라서 N^2번 i와 k를 출력하게 되므로 시간복잡도는 O(N^2)이다.

~~~cpp
int N;
cin >> N;
for(int i=0;i<10;i++){
  for(int k=0;k<N;k++){
    cout << i << " " << k << "\n";
  }
}
~~~
하지만 위와같은 코드는 
for문이 두개 겹쳐있지만 i의 수행횟수가 10회로 고정되있으므로 수행횟수는 10N 이 될것이고 시간복잡도는 O(N)으로 표기된다.
따라서 시간복잡도는 N으 변화에 따른 수행횟수의 변화식이라고 생각할 수 있다.

## 4.6 수행 시간 어림짐작하기
### 주먹구구 법칙
입력 N의 최대크기가 10000이고 테스트 케이스 하나의 시간제한이 1초라고 한다면 어떻게 해야할까
알고리즘 대회 참가자들은 대부분 반복문의 수행횟수가 초당 1억을 넘어가면 시간제한을 초과할 가능성이 있다고 생각한다.
이런경우 O(N^3)의 경우는 확실하게 넘어갈 것이고, O(log (N))인 경우에도 마찬가지로 확실하게 넘지 않을것이다.
하지만 O(N^2)의 경우에는 연산횟수가 1억번이므로 애매해질 수 있다. 이경우 시간이 초과할지 않을지는 확실하게 말할 수 없다.







